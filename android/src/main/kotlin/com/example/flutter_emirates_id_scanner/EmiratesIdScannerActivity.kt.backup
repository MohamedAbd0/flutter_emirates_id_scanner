package com.example.flutter_emirates_id_scanner

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.*
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Button
import android.widget.FrameLayout
import android.widget.TextView
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.*
import androidx.camera.core.Camera
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import androidx.exifinterface.media.ExifInterface
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.latin.TextRecognizerOptions
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class EmiratesIdScannerActivity : AppCompatActivity() {
    
    private lateinit var viewFinder: PreviewView
    private lateinit var overlayView: View
    private lateinit var instructionText: TextView
    private lateinit var closeButton: Button
    private lateinit var cameraExecutor: ExecutorService
    
    private var imageCapture: ImageCapture? = null
    private var imageAnalyzer: ImageAnalysis? = null
    private var camera: Camera? = null
    
    private var scanningStep = ScanningStep.FRONT
    private var isCapturing = false  // Add capture state management
    private var lastProcessTime = 0L  // Add timeout tracking
    private var frontImagePath: String? = null
    private var backImagePath: String? = null
    private var frontSideContent: String? = null
    private var backSideContent: String? = null
    private var extractedData = mutableMapOf<String, String?>()
    
    // Rectangle bounds for cropping
    private var rectangleBounds: RectF? = null
    
    enum class ScanningStep {
        FRONT, BACK, COMPLETED
    }
    
    companion object {
        private const val TAG = "EmiratesIdScanner"
        const val RESULT_SUCCESS = "success"
        const val RESULT_CANCELLED = "cancelled"
        const val RESULT_ERROR = "error"
    }
    
    private val textRecognizer = TextRecognition.getClient(TextRecognizerOptions.DEFAULT_OPTIONS)
    
    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        if (isGranted) {
            startCamera()
        } else {
            finishWithError("Camera permission denied")
        }
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(createLayout())
        
        cameraExecutor = Executors.newSingleThreadExecutor()
        
        if (allPermissionsGranted()) {
            startCamera()
        } else {
            requestPermissionLauncher.launch(Manifest.permission.CAMERA)
        }
        
        updateInstruction()
    }
    
    private fun createLayout(): View {
        val rootLayout = FrameLayout(this).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )
            setBackgroundColor(Color.BLACK)
        }
        
        // Camera preview
        viewFinder = PreviewView(this).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )
        }
        rootLayout.addView(viewFinder)
        
        // Overlay view for ID card frame
        overlayView = createOverlayView()
        rootLayout.addView(overlayView)
        
        // Instruction text
        instructionText = TextView(this).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                topMargin = 100
                leftMargin = 40
                rightMargin = 40
            }
            textSize = 18f
            setTextColor(Color.WHITE)
            textAlignment = View.TEXT_ALIGNMENT_CENTER
            setBackgroundColor(Color.parseColor("#80000000"))
            setPadding(20, 20, 20, 20)
        }
        rootLayout.addView(instructionText)
        
        // Close button
        closeButton = Button(this).apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.WRAP_CONTENT,
                FrameLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                topMargin = 50
                rightMargin = 20
                gravity = android.view.Gravity.TOP or android.view.Gravity.END
            }
            text = "✕"
            textSize = 20f
            setTextColor(Color.WHITE)
            setBackgroundColor(Color.parseColor("#80000000"))
            setPadding(20, 10, 20, 10)
            setOnClickListener {
                finishWithResult(RESULT_CANCELLED, null)
            }
        }
        rootLayout.addView(closeButton)
        
        return rootLayout
    }
    
    private fun createOverlayView(): View {
        return object : View(this) {
            override fun onDraw(canvas: Canvas) {
                super.onDraw(canvas)
                canvas.let { c ->
                    // Calculate rectangle bounds for Emirates ID scanning
                    val centerX = width / 2f
                    val centerY = height / 2f
                    val cardWidth = width * 0.85f  // Slightly larger for better visibility
                    val cardHeight = cardWidth * 0.63f // Emirates ID aspect ratio (85.6mm × 53.98mm)
                    
                    val left = centerX - cardWidth / 2
                    val top = centerY - cardHeight / 2
                    val right = centerX + cardWidth / 2
                    val bottom = centerY + cardHeight / 2
                    
                    // Store rectangle bounds for reference
                    rectangleBounds = RectF(left, top, right, bottom)
                    
                    // Draw semi-black overlay outside scanning rectangle (darker overlay)
                    val overlayPaint = Paint().apply {
                        color = Color.parseColor("#00000000") // More opaque black 
                        style = Paint.Style.FILL
                        isAntiAlias = true
                    }
                    
                    // Draw overlay on all four sides to create scanning window
                    c.drawRect(0f, 0f, width.toFloat(), top, overlayPaint) // Top area
                    c.drawRect(0f, bottom, width.toFloat(), height.toFloat(), overlayPaint) // Bottom area
                    c.drawRect(0f, top, left, bottom, overlayPaint) // Left area
                    c.drawRect(right, top, width.toFloat(), bottom, overlayPaint) // Right area
                    
                    // Draw Emirates ID scanning frame with enhanced visibility
                    val framePaint = Paint().apply {
                        color = Color.WHITE
                        style = Paint.Style.STROKE
                        strokeWidth = 3f
                        isAntiAlias = true
                    }
                    
                    // Draw main scanning rectangle
                    c.drawRect(left, top, right, bottom, framePaint)
                    
                    // Draw corner guides for better alignment
                    val cornerLength = 40f
                    val cornerPaint = Paint().apply {
                        color = Color.parseColor("#00E676") // Green color for corners
                        style = Paint.Style.STROKE
                        strokeWidth = 6f
                        isAntiAlias = true
                        strokeCap = Paint.Cap.ROUND
                    }
                    
                    // Top-left corner
                    c.drawLine(left, top, left + cornerLength, top, cornerPaint)
                    c.drawLine(left, top, left, top + cornerLength, cornerPaint)
                    
                    // Top-right corner
                    c.drawLine(right - cornerLength, top, right, top, cornerPaint)
                    c.drawLine(right, top, right, top + cornerLength, cornerPaint)
                    
                    // Bottom-left corner
                    c.drawLine(left, bottom - cornerLength, left, bottom, cornerPaint)
                    c.drawLine(left, bottom, left + cornerLength, bottom, cornerPaint)
                    
                    // Bottom-right corner
                    c.drawLine(right - cornerLength, bottom, right, bottom, cornerPaint)
                    c.drawLine(right, bottom - cornerLength, right, bottom, cornerPaint)
                    
                    // Draw center alignment guide
                    val centerLinePaint = Paint().apply {
                        color = Color.parseColor("#4DFFFFFF") // Semi-transparent white
                        style = Paint.Style.STROKE
                        strokeWidth = 1f
                        pathEffect = android.graphics.DashPathEffect(floatArrayOf(10f, 10f), 0f)
                    }
                    
                    // Horizontal center line
                    c.drawLine(left + 20f, centerY, right - 20f, centerY, centerLinePaint)
                    // Vertical center line  
                    c.drawLine(centerX, top + 20f, centerX, bottom - 20f, centerLinePaint)
                }
            }
        }.apply {
            layoutParams = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                FrameLayout.LayoutParams.MATCH_PARENT
            )
        }
    }
    
    private fun updateInstruction() {
        val instruction = when (scanningStep) {
            ScanningStep.FRONT -> "قُم بمسح الوجه الأمامي للهوية"
            ScanningStep.BACK -> "قُم بمسح الوجه الخلفي للهوية"
            ScanningStep.COMPLETED -> "جيد"
        }
        instructionText.text = instruction
    }
    
    private fun allPermissionsGranted() = ContextCompat.checkSelfPermission(
        this, Manifest.permission.CAMERA
    ) == PackageManager.PERMISSION_GRANTED
    
    private fun startCamera() {
        // Don't start camera if we've completed scanning
        if (scanningStep == ScanningStep.COMPLETED) {
            Log.d(TAG, "Skipping camera start - scanning completed")
            return
        }
        
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        
        cameraProviderFuture.addListener({
            try {
                val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()
                
                // Unbind all use cases before rebinding to avoid conflicts
                cameraProvider.unbindAll()
                
                // Create preview use case
                val preview = Preview.Builder().build().also {
                    it.setSurfaceProvider(viewFinder.surfaceProvider)
                }
                
                // Create image capture use case with enhanced configuration
                imageCapture = ImageCapture.Builder()
                    .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)  // Use minimize latency for better reliability
                    .setTargetRotation(windowManager.defaultDisplay.rotation)  // Set proper rotation
                    .setIoExecutor(cameraExecutor)  // Use dedicated executor for IO operations
                    .build()
                
                // Create image analyzer use case
                imageAnalyzer = ImageAnalysis.Builder()
                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                    .build()
                    .also {
                        it.setAnalyzer(cameraExecutor, ImageAnalyzer())
                    }
                
                val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA
                
                try {
                    // Try to bind all use cases to the lifecycle
                    camera = cameraProvider.bindToLifecycle(
                        this, cameraSelector, preview, imageCapture, imageAnalyzer
                    )
                    Log.d(TAG, "Camera bound successfully with all use cases")
                } catch (exc: Exception) {
                    // If binding fails, try without the analyzer as a fallback
                    Log.e(TAG, "Use case binding failed, trying without analyzer", exc)
                    try {
                        camera = cameraProvider.bindToLifecycle(
                            this, cameraSelector, preview, imageCapture
                        )
                        Log.d(TAG, "Camera bound without analyzer (fallback mode)")
                    } catch (e: Exception) {
                        Log.e(TAG, "Camera binding failed completely", e)
                        finishWithError("Failed to start camera: ${e.message}")
                    }
                }
            } catch (exc: Exception) {
                Log.e(TAG, "Camera provider error", exc)
                finishWithError("Camera initialization error: ${exc.message}")
            }
        }, ContextCompat.getMainExecutor(this))
    }
    
    private inner class ImageAnalyzer : ImageAnalysis.Analyzer {
        override fun analyze(imageProxy: ImageProxy) {
            // Check early if we're done with scanning or currently capturing
            if (scanningStep == ScanningStep.COMPLETED || isCapturing) {
                if (isCapturing) {
                    Log.v(TAG, "ImageAnalyzer: Skipping analysis - capture in progress for ${scanningStep.name}")
                }
                imageProxy.close()
                return
            }
            
            // Add throttling to prevent excessive processing
            val currentTime = System.currentTimeMillis()
            if (currentTime - lastProcessTime < 1000) { // Limit to once per second
                imageProxy.close()
                return
            }
            lastProcessTime = currentTime
            
            Log.v(TAG, "ImageAnalyzer: Processing image for ${scanningStep.name} side")
            
            val mediaImage = imageProxy.image
            if (mediaImage != null) {
                val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)
                
                // Process image for text recognition with timeout
                textRecognizer.process(image)
                    .addOnSuccessListener { visionText ->
                        // Double-check if we're still scanning and not capturing before processing
                        if (scanningStep != ScanningStep.COMPLETED && !isCapturing) {
                            processTextResult(visionText.text)
                        }
                    }
                    .addOnFailureListener { e ->
                        Log.e(TAG, "Text recognition failed", e)
                    }
                    .addOnCompleteListener {
                        // Always close the image proxy when done
                        try {
                            imageProxy.close()
                        } catch (e: Exception) {
                            Log.w(TAG, "Failed to close image proxy: ${e.message}")
                        }
                    }
            } else {
                imageProxy.close()
            }
        }
    }
    
    private fun processTextResult(text: String) {
        // Skip processing if we're already completed or capturing
        if (scanningStep == ScanningStep.COMPLETED || isCapturing) {
            return
        }
        
        Log.d(TAG, "OCR Text: $text")
        
        val isValidCard = when (scanningStep) {
            ScanningStep.FRONT -> isValidFrontSide(text)
            ScanningStep.BACK -> isValidBackSide(text)
            ScanningStep.COMPLETED -> false
        }
        
        if (isValidCard) {
            // Set capturing state to prevent further analysis
            isCapturing = true
            
            Log.d(TAG, "Valid ${scanningStep.name} side detected, starting capture process")
            
            runOnUiThread {
                instructionText.text = "جيد"
            }
            
            // Delay capture to allow user to see "Good" message
            lifecycleScope.launch {
                kotlinx.coroutines.delay(1000)
                Log.d(TAG, "About to call captureImage() for ${scanningStep.name} side")
                captureImage()
            }
        }
    }
    
    private fun isValidFrontSide(text: String): Boolean {
        val cleanText = text.replace("\\s+".toRegex(), " ").uppercase()
        
        // Check for ID number with pattern 784-YYYY-XXXXXXX-X (where 784 is UAE country code)
        val idPattern = Regex("784-\\d{4}-\\d{7}-\\d{1}")
        val hasIdNumber = text.contains(idPattern)
        
        // Check for key header text
        val hasHeaderText = cleanText.contains("UNITED ARAB EMIRATES") || 
                          cleanText.contains("الإمارات العربية المتحدة") ||
                          cleanText.contains("FEDERAL AUTHORITY")
        
        // Check for nationality field
        val hasNationality = cleanText.contains("NATIONALITY") || cleanText.contains("الجنسية")
        
        // Check for date patterns (DD/MM/YYYY)
        val datePattern = Regex("\\d{2}/\\d{2}/\\d{4}")
        val hasDateFormat = text.contains(datePattern)
        
        // ID Card specific fields
        val hasCardText = cleanText.contains("IDENTITY CARD") || 
                        cleanText.contains("بطاقة هوية") || 
                        cleanText.contains("RESIDENT IDENTITY CARD")
        
        // Return true if we have at least two strong indicators
        return (hasIdNumber || (hasHeaderText && (hasDateFormat || hasNationality || hasCardText)))
    }
    
    private fun isValidBackSide(text: String): Boolean {
        val cleanText = text.replace("\\s+".toRegex(), " ").uppercase()
        
        // Check for Card Number label which is specific to the back side
        val hasCardNumber = cleanText.contains("CARD NUMBER") || cleanText.contains("رقم البطاقة")
        
        // Check for occupation field which appears on back side
        val hasOccupation = cleanText.contains("OCCUPATION") || cleanText.contains("المهنة")
        
        // Check for employer field which appears on back side
        val hasEmployer = cleanText.contains("EMPLOYER") || cleanText.contains("صاحب العمل")
        
        // Check for issuing place field which appears on back side
        val hasIssuingPlace = cleanText.contains("ISSUING PLACE") || cleanText.contains("مكان الإصدار")
        
        // Check for specific places like Abu Dhabi, Dubai, Al Ain, Sharjah, Ajman, Fujairah, Ras Al Khaimah, and Umm Al Quwain
        val hasEmirateLocation = cleanText.contains("ABU DHABI") || 
                               cleanText.contains("DUBAI") || 
                               cleanText.contains("SHARJAH") || 
                               cleanText.contains("أبوظبي") || 
                               cleanText.contains("دبي") || 
                               cleanText.contains("الشارقة")
        
        // Check for the machine readable zone (MRZ) pattern with multiple '<' characters
        val hasMrzPattern = text.contains("<<<<<<") || text.count { it == '<' } > 5
        
        // Check for electronic chip references
        val hasChipInfo = cleanText.contains("CHIP") || 
                        text.contains(Regex("\\d{8,}")) // Long numerical sequences for chip ID
        
        
        // Return true if we have at least two strong indicators of back side
        return ((hasCardNumber || hasOccupation || hasEmployer || hasIssuingPlace) && 
                (hasMrzPattern || hasChipInfo || hasEmirateLocation ))
    }
    
    /**
     * Checks if the current scanned side is a duplicate of a previously scanned side
     * based on text content comparison instead of image hash
     */
    private fun isDuplicateCardSide(newText: String, isFrontSide: Boolean): Boolean {
        // Clean the text for better comparison
        val cleanedText = newText.replace("\\s+".toRegex(), " ").uppercase()
        
        if (isFrontSide) {
            // Check if this front side text is similar to already scanned back side content
            if (backSideContent != null) {
                // Content similarity check
                return hasSimilarContent(cleanedText, backSideContent!!)
            }
        } else {
            // Check if this back side text is similar to already scanned front side content
            if (frontSideContent != null) {
                return hasSimilarContent(cleanedText, frontSideContent!!)
            }
        }
        
        return false
    }
    
    /**
     * Compares two text contents to determine if they likely represent the same side of a card
     * This uses multiple criteria to make the decision more robust
     */
    private fun hasSimilarContent(text1: String, text2: String): Boolean {
        // --- SPECIFIC ID NUMBER CHECK ---
        // If both texts contain the same ID number pattern, they are likely the same
        val idPattern = Regex("784-\\d{4}-\\d{7}-\\d{1}")
        val idMatches1 = idPattern.findAll(text1).map { it.value }.toList()
        val idMatches2 = idPattern.findAll(text2).map { it.value }.toList()
        
        // If both sides have the same ID number, they are definitely the same side
        if (idMatches1.isNotEmpty() && idMatches2.isNotEmpty() && idMatches1.any { idMatches2.contains(it) }) {
            Log.d(TAG, "Same ID number found on both scans")
            return true
        }
        
        // --- FRONT SIDE SPECIFIC CHECK ---
        // Check for key phrases that should appear only on front side
        val frontSideKeywords = listOf(
            "UNITED ARAB EMIRATES", "الإمارات العربية المتحدة", "FEDERAL AUTHORITY",
            "IDENTITY CARD", "بطاقة هوية", "RESIDENT IDENTITY CARD"
        )
        
        var frontSideMatches1 = 0
        var frontSideMatches2 = 0
        
        for (keyword in frontSideKeywords) {
            if (text1.contains(keyword)) frontSideMatches1++
            if (text2.contains(keyword)) frontSideMatches2++
        }
        
        // If both texts have multiple front side indicators, they are likely both front sides
        val isBothFront = frontSideMatches1 >= 2 && frontSideMatches2 >= 2
        
        // --- BACK SIDE SPECIFIC CHECK ---
        // Check for key phrases that should appear only on back side
        val backSideKeywords = listOf(
            "CARD NUMBER", "رقم البطاقة", "OCCUPATION", "المهنة",
            "EMPLOYER", "صاحب العمل", "ISSUING PLACE", "مكان الإصدار"
        )
        
        var backSideMatches1 = 0
        var backSideMatches2 = 0
        
        for (keyword in backSideKeywords) {
            if (text1.contains(keyword)) backSideMatches1++
            if (text2.contains(keyword)) backSideMatches2++
        }
        
        // Check for MRZ pattern which is specific to back side
        val hasMrzPattern1 = text1.contains("<<<<<<") || text1.count { it == '<' } > 5
        val hasMrzPattern2 = text2.contains("<<<<<<") || text2.count { it == '<' } > 5
        
        if (hasMrzPattern1) backSideMatches1++
        if (hasMrzPattern2) backSideMatches2++
        
        // If both texts have multiple back side indicators, they are likely both back sides
        val isBothBack = backSideMatches1 >= 2 && backSideMatches2 >= 2
        
        // Log result for debugging
        if (isBothFront || isBothBack) {
            Log.d(TAG, "Duplicate side detected: isBothFront=$isBothFront, isBothBack=$isBothBack")
        }
        
        return isBothFront || isBothBack
    }
    
    private fun getExifOrientation(imagePath: String): Int {
        return try {
            val exif = ExifInterface(imagePath)
            exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)
        } catch (e: Exception) {
            Log.w(TAG, "Failed to read EXIF data: ${e.message}")
            ExifInterface.ORIENTATION_NORMAL
        }
    }
    
    private fun rotateBitmap(bitmap: Bitmap, orientation: Int): Bitmap {
        val matrix = Matrix()
        when (orientation) {
            ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
            ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
            ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
            ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> matrix.preScale(-1f, 1f)
            ExifInterface.ORIENTATION_FLIP_VERTICAL -> matrix.preScale(1f, -1f)
            ExifInterface.ORIENTATION_TRANSPOSE -> {
                matrix.postRotate(90f)
                matrix.preScale(-1f, 1f)
            }
            ExifInterface.ORIENTATION_TRANSVERSE -> {
                matrix.postRotate(-90f)
                matrix.preScale(-1f, 1f)
            }
            else -> return bitmap // No rotation needed
        }
        
        return try {
            val rotatedBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
            if (rotatedBitmap != bitmap) {
                bitmap.recycle() // Recycle original bitmap to free memory
            }
            rotatedBitmap
        } catch (e: Exception) {
            Log.e(TAG, "Failed to rotate bitmap: ${e.message}")
            bitmap // Return original bitmap if rotation fails
        }
    }
    
    private fun cropImageToRectangle(originalPath: String, outputPath: String): Boolean {
        return try {
            // Get EXIF orientation before decoding
            val exifOrientation = getExifOrientation(originalPath)
            Log.d(TAG, "EXIF orientation: $exifOrientation")
            
            var originalBitmap = BitmapFactory.decodeFile(originalPath)
            if (originalBitmap == null) {
                Log.e(TAG, "Failed to decode image: $originalPath")
                return false
            }
            
            Log.d(TAG, "Original image size before rotation: ${originalBitmap.width} x ${originalBitmap.height}")
            
            // Apply EXIF rotation to fix image orientation
            originalBitmap = rotateBitmap(originalBitmap, exifOrientation)
            
            Log.d(TAG, "Original image size after rotation: ${originalBitmap.width} x ${originalBitmap.height}")
            
            // Get the viewfinder dimensions (which should match overlay dimensions)
            val overlayWidth = viewFinder.width.toFloat()
            val overlayHeight = viewFinder.height.toFloat()
            
            Log.d(TAG, "Preview size: $overlayWidth x $overlayHeight")
            
            // Calculate Emirates ID card dimensions (must match overlay calculations exactly)
            val cardWidth = overlayWidth * 0.85f  // Same as overlay
            val cardHeight = cardWidth * 0.63f // Emirates ID aspect ratio
            
            val centerX = overlayWidth / 2f
            val centerY = overlayHeight / 2f
            
            val rectLeft = centerX - cardWidth / 2f
            val rectTop = centerY - cardHeight / 2f
            val rectWidth = cardWidth
            val rectHeight = cardHeight
            
            Log.d(TAG, "Card rectangle: left=$rectLeft, top=$rectTop, width=$rectWidth, height=$rectHeight")
            
            // Calculate how the camera preview maps to the captured image
            // The preview might be scaled/cropped to fit the view
            val imageAspectRatio = originalBitmap.width.toFloat() / originalBitmap.height.toFloat()
            val previewAspectRatio = overlayWidth / overlayHeight
            
            val scaleX: Float
            val scaleY: Float
            val offsetX: Float
            val offsetY: Float
            
            if (imageAspectRatio > previewAspectRatio) {
                // Image is wider than preview - image is cropped horizontally
                scaleY = originalBitmap.height.toFloat() / overlayHeight
                scaleX = scaleY
                offsetY = 0f
                offsetX = (originalBitmap.width - overlayWidth * scaleX) / 2f
            } else {
                // Image is taller than preview - image is cropped vertically  
                scaleX = originalBitmap.width.toFloat() / overlayWidth
                scaleY = scaleX
                offsetX = 0f
                offsetY = (originalBitmap.height - overlayHeight * scaleY) / 2f
            }
            
            Log.d(TAG, "Scale: x=$scaleX, y=$scaleY, Offset: x=$offsetX, y=$offsetY")
            
            // Map overlay coordinates to image coordinates
            val cropLeft = (rectLeft * scaleX + offsetX).toInt().coerceAtLeast(0)
            val cropTop = (rectTop * scaleY + offsetY).toInt().coerceAtLeast(0)
            val cropWidth = (rectWidth * scaleX).toInt()
                .coerceAtMost(originalBitmap.width - cropLeft)
            val cropHeight = (rectHeight * scaleY).toInt()
                .coerceAtMost(originalBitmap.height - cropTop)
            
            Log.d(TAG, "Crop bounds: left=$cropLeft, top=$cropTop, width=$cropWidth, height=$cropHeight")
            
            if (cropWidth <= 0 || cropHeight <= 0) {
                Log.e(TAG, "Invalid crop dimensions")
                return false
            }
            
            val croppedBitmap = Bitmap.createBitmap(
                originalBitmap, 
                cropLeft, 
                cropTop, 
                cropWidth, 
                cropHeight
            )
            
            // Save cropped bitmap with corrected orientation
            FileOutputStream(outputPath).use { out ->
                croppedBitmap.compress(Bitmap.CompressFormat.JPEG, 95, out)
            }
            
            Log.d(TAG, "Cropped image saved: $outputPath (${croppedBitmap.width} x ${croppedBitmap.height})")
            
            originalBitmap.recycle()
            croppedBitmap.recycle()
            
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to crop image: ${e.message}", e)
            false
        }
    }
    
    private fun captureImage() {
        Log.d(TAG, "captureImage() called for ${scanningStep.name} side")
        
        // Safety checks to prevent freezing
        if (scanningStep == ScanningStep.COMPLETED) {
            Log.d(TAG, "Skipping capture - scanning already completed")
            return
        }
        
        // Prevent multiple concurrent capture requests
        if (isCapturing) {
            Log.d(TAG, "Capture already in progress, ignoring duplicate request")
            return
        }
        
        isCapturing = true
        Log.d(TAG, "Set isCapturing = true for ${scanningStep.name} side")
        
        // Add timeout to reset isCapturing flag in case capture gets stuck
        lifecycleScope.launch {
            delay(15000) // 15 second timeout
            if (isCapturing) {
                Log.w(TAG, "Capture timeout reached, resetting isCapturing flag")
                isCapturing = false
                runOnUiThread {
                    instructionText.text = "حدث خطأ في التصوير، يرجى المحاولة مرة أخرى"
                }
                lifecycleScope.launch {
                    delay(3000)
                    runOnUiThread {
                        updateInstruction()
                    }
                }
            }
        }
        
        val imageCapture = imageCapture ?: run {
            Log.e(TAG, "ImageCapture is null, cannot capture image")
            isCapturing = false
            return
        }
        
        // Ensure camera is still bound
        if (camera == null) {
            Log.e(TAG, "Camera is null, attempting to restart")
            isCapturing = false
            startCamera()
            return
        }
        
        Log.d(TAG, "ImageCapture and Camera are ready, proceeding with capture")
        
        val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
        val tempFileName = when (scanningStep) {
            ScanningStep.FRONT -> "emirates_id_front_temp_$timestamp.jpg"
            ScanningStep.BACK -> "emirates_id_back_temp_$timestamp.jpg"
            ScanningStep.COMPLETED -> return
        }
        
        val finalFileName = when (scanningStep) {
            ScanningStep.FRONT -> "emirates_id_front_$timestamp.jpg"
            ScanningStep.BACK -> "emirates_id_back_$timestamp.jpg"
            ScanningStep.COMPLETED -> return
        }
        
        val tempFile = File(cacheDir, tempFileName)
        val finalFile = File(cacheDir, finalFileName)
        val outputFileOptions = ImageCapture.OutputFileOptions.Builder(tempFile).build()
        
        Log.d(TAG, "Starting image capture for step: $scanningStep")
        
        // Use the dedicated cameraExecutor for capture operations to ensure proper thread handling
        imageCapture.takePicture(
            outputFileOptions,
            cameraExecutor,  // Use cameraExecutor instead of MainExecutor for better reliability
            object : ImageCapture.OnImageSavedCallback {
                override fun onError(exception: ImageCaptureException) {
                    Log.e(TAG, "Image capture failed for ${scanningStep.name}: ${exception.message}", exception)
                    Log.e(TAG, "ImageCaptureException details - error code: ${exception.imageCaptureError}")
                    
                    // Use runOnUiThread to ensure UI updates happen on main thread
                    runOnUiThread {
                        isCapturing = false  // Reset capture state on error
                        finishWithError("Failed to capture image: ${exception.message}")
                    }
                }
                
                override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                    Log.d(TAG, "onImageSaved callback triggered for ${scanningStep.name} side")
                    Log.d(TAG, "Image saved successfully, output URI: ${output.savedUri}")
                    
                    // Ensure UI operations happen on main thread
                    runOnUiThread {
                        try {
                            // Double-check we're still in the expected scanning step
                            if (scanningStep == ScanningStep.COMPLETED) {
                                Log.d(TAG, "Image captured but scanning already completed, cleaning up")
                                tempFile.delete()
                                isCapturing = false
                                return@runOnUiThread
                            }
                            
                            Log.d(TAG, "Processing captured image for ${scanningStep.name} side")
                            processCompletedCapture(tempFile, finalFile)
                        } catch (e: Exception) {
                            Log.e(TAG, "Error in onImageSaved processing: ${e.message}", e)
                            isCapturing = false
                            finishWithError("Error processing captured image: ${e.message}")
                        }
                    }
                }
            }
        )
    }
    
    private fun processCompletedCapture(tempFile: File, finalFile: File) {
        Log.d(TAG, "processCompletedCapture called for ${scanningStep.name} side")
        val tempImagePath = tempFile.absolutePath
        Log.d(TAG, "Temp image captured: $tempImagePath")
        
        // Crop the image to rectangle area
        Log.d(TAG, "Starting image cropping...")
        val cropSuccess = cropImageToRectangle(tempImagePath, finalFile.absolutePath)
        Log.d(TAG, "Image cropping result: $cropSuccess")
        
        if (!cropSuccess) {
            Log.e(TAG, "Failed to crop image, but continuing...")
            // Show guidance message instead of finishing with error
            when (scanningStep) {
                ScanningStep.FRONT -> {
                    instructionText.text = "Please try scanning the front side again"
                }
                ScanningStep.BACK -> {
                    instructionText.text = "Please try scanning the back side again"
                }
                ScanningStep.COMPLETED -> return
            }
            // Reset instruction after delay
            lifecycleScope.launch {
                delay(3000)
                updateInstruction()
            }
            // Clean up temp file and reset state
            tempFile.delete()
            isCapturing = false  // Reset capture state
            return
        }
        
        Log.d(TAG, "Processing captured image for ${scanningStep.name} side")
        
        when (scanningStep) {
            ScanningStep.FRONT -> {
                Log.d(TAG, "Processing front side image...")
                // Extract text from image to check for front side indicators
                lifecycleScope.launch {
                    try {
                        Log.d(TAG, "Extracting text from front side image...")
                        val frontText = extractTextFromImage(finalFile.absolutePath)
                        Log.d(TAG, "Front side text extraction completed, validating...")
                        val isFrontSide = isValidFrontSide(frontText)
                        Log.d(TAG, "Front side validation result: $isFrontSide")
                        
                        if (!isFrontSide) {
                            // This doesn't look like a front side
                            Log.w(TAG, "Image doesn't appear to be front side of Emirates ID")
                            // Show error message and stay on front scanning
                            runOnUiThread {
                                instructionText.text = "هذه ليست الواجهة الأمامية للبطاقة، يرجى مسح الوجه الأمامي"
                            }
                            // Delete the invalid image
                            finalFile.delete()
                            // Reset instruction after delay
                            lifecycleScope.launch {
                                delay(3000)
                                runOnUiThread {
                                    updateInstruction()
                                }
                            }
                            isCapturing = false  // Reset capture state
                            return@launch
                        }
                        
                        Log.d(TAG, "Checking for duplicate front side...")
                        // Check if the front side is a duplicate of the back (in case user scanned back first)
                        if (backSideContent != null && isDuplicateCardSide(frontText, isFrontSide = true)) {
                            Log.w(TAG, "This appears to be a duplicate of the back side")
                            runOnUiThread {
                                instructionText.text = "هذه نفس الواجهة الخلفية، يرجى مسح الوجه الأمامي للبطاقة"
                            }
                            // Delete the invalid image
                            finalFile.delete()
                            // Reset instruction after delay
                            lifecycleScope.launch {
                                delay(3000)
                                runOnUiThread {
                                    updateInstruction()
                                }
                            }
                            isCapturing = false  // Reset capture state
                            return@launch
                        }
                        
                        frontImagePath = finalFile.absolutePath
                        frontSideContent = frontText
                        scanningStep = ScanningStep.BACK
                        
                        // Show completion message for front side
                        runOnUiThread {
                            instructionText.text = "تم مسح الوجه الأمامي بنجاح. الآن قم بمسح الوجه الخلفي للهوية"
                        }
                        
                        // CRITICAL: Reset isCapturing before transitioning to back side
                        Log.d(TAG, "Front side processed successfully, resetting isCapturing for back side scanning")
                        isCapturing = false
                        
                        // Restart camera for back side scanning with improved resource management
                        restartCameraForNextStep()
                    } catch (e: Exception) {
                        Log.e(TAG, "Error processing front side: ${e.message}", e)
                        isCapturing = false
                        runOnUiThread {
                            finishWithError("Error processing front side: ${e.message}")
                        }
                    }
                }
            }
            ScanningStep.BACK -> {
                Log.d(TAG, "Processing back side image...")
                // Extract text from image to check for back side indicators
                lifecycleScope.launch {
                    try {
                        val backText = extractTextFromImage(finalFile.absolutePath)
                        
                        // First check if this is actually a back side
                        val isBackSide = isValidBackSide(backText)
                        if (!isBackSide) {
                            // This doesn't look like a back side
                            Log.w(TAG, "Image doesn't appear to be back side of Emirates ID")
                            // Show error message and stay on back scanning
                            runOnUiThread {
                                instructionText.text = "هذه ليست الواجهة الخلفية للبطاقة، يرجى مسح الوجه الخلفي"
                            }
                            // Delete the invalid image
                            finalFile.delete()
                            // Reset instruction after delay
                            lifecycleScope.launch {
                                delay(3000)
                                runOnUiThread {
                                    updateInstruction()
                                }
                            }
                            isCapturing = false  // Reset capture state
                            return@launch
                        }
                        
                        // Check if this is a duplicate of the front side
                        if (frontSideContent != null && isDuplicateCardSide(backText, isFrontSide = false)) {
                            Log.w(TAG, "This appears to be a duplicate of the front side")
                            runOnUiThread {
                                instructionText.text = "هذه نفس الواجهة الأمامية، يرجى مسح الوجه الخلفي للبطاقة"
                            }
                            // Delete the invalid image
                            finalFile.delete()
                            // Reset instruction after delay
                            lifecycleScope.launch {
                                delay(3000)
                                runOnUiThread {
                                    updateInstruction()
                                }
                            }
                            isCapturing = false  // Reset capture state
                            return@launch
                        }
                        
                        backImagePath = finalFile.absolutePath
                        scanningStep = ScanningStep.COMPLETED
                        
                        Log.d(TAG, "Both sides captured successfully!")
                        Log.d(TAG, "Front image: $frontImagePath")
                        Log.d(TAG, "Back image: $backImagePath")
                        
                        // Finish scanning with successful result
                        runOnUiThread {
                            finishWithResult(RESULT_OK, mapOf(
                                "frontImagePath" to frontImagePath,
                                "backImagePath" to backImagePath
                            ))
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error processing back side: ${e.message}", e)
                        isCapturing = false
                        runOnUiThread {
                            finishWithError("Error processing back side: ${e.message}")
                        }
                    }
                }
            }
            ScanningStep.COMPLETED -> {
                Log.d(TAG, "Scanning already completed, ignoring capture")
                isCapturing = false
            }
        }
        
        // Clean up temp file
        tempFile.delete()
                            }
                        }
                        ScanningStep.BACK -> {
                            // Check if this is actually the same side as the front (duplicate scan)
                            if (isDuplicateCardSide(backText, isFrontSide = false)) {
                                Log.w(TAG, "This appears to be a duplicate of the front side")
                                runOnUiThread {
                                    instructionText.text = "هذه نفس الواجهة الأمامية، يرجى مسح الوجه الخلفي للبطاقة"
                                }
                                // Delete the invalid image
                                finalFile.delete()
                                // Reset instruction after delay
                                lifecycleScope.launch {
                                    delay(3000)
                                    runOnUiThread {
                                        updateInstruction()
                                    }
                                }
                                isCapturing = false  // Reset capture state
                                return
                            }
                            
                            // We've now confirmed this is a valid back side, store it
                            backImagePath = finalFile.absolutePath
                            backSideContent = backText
                            scanningStep = ScanningStep.COMPLETED
                            
                            // Show completion message for back side
                            runOnUiThread {
                                instructionText.text = "تم مسح الوجه الخلفي بنجاح. جاري معالجة البيانات..."
                            }
                            
                            // Delay before processing
                            lifecycleScope.launch {
                                delay(1500)
                                processCompleted()
                            }
                        }
                        ScanningStep.COMPLETED -> return
                    }
                    
                    // Clean up temp file
                    tempFile.delete()
                }
            }
        )
    }
    
    private fun processCompleted() {
        lifecycleScope.launch {
            try {
                // Extract data from both images
                extractDataFromImages()
                
                val result = mapOf(
                    "fullName" to extractedData["fullName"],
                    "idNumber" to extractedData["idNumber"],
                    "nationality" to extractedData["nationality"],
                    "dateOfBirth" to extractedData["dateOfBirth"],
                    "issueDate" to extractedData["issueDate"],
                    "expiryDate" to extractedData["expiryDate"],
                    "frontImagePath" to frontImagePath,
                    "backImagePath" to backImagePath,
                    "cardNumber" to extractedData["cardNumber"],
                    "occupation" to extractedData["occupation"],
                    "employer" to extractedData["employer"],
                    "issuingPlace" to extractedData["issuingPlace"],
                    "mrzData" to extractedData["mrzData"]
                )
                
                finishWithResult(RESULT_SUCCESS, result)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to process images", e)
                finishWithError("Failed to process captured images: ${e.message}")
            }
        }
    }
    
    private suspend fun extractDataFromImages() {
        frontImagePath?.let { path ->
            val frontText = extractTextFromImage(path)
            extractFrontSideData(frontText)
        }
        
        backImagePath?.let { path ->
            val backText = extractTextFromImage(path)
            extractBackSideData(backText)
        }
    }
    
    private suspend fun extractTextFromImage(imagePath: String): String {
        return kotlinx.coroutines.suspendCancellableCoroutine { continuation ->
            val file = File(imagePath)
            val image = InputImage.fromFilePath(this, android.net.Uri.fromFile(file))
            
            textRecognizer.process(image)
                .addOnSuccessListener { visionText ->
                    continuation.resume(visionText.text) {}
                }
                .addOnFailureListener { e ->
                    continuation.resume("") {}
                }
        }
    }
    
    private fun extractFrontSideData(text: String) {
        val lines = text.split("\n")
        
        // Extract ID Number (pattern: XXX-XXXX-XXXXXXX-X)
        val idPattern = Regex("(\\d{3}-\\d{4}-\\d{7}-\\d{1})")
        val idMatch = idPattern.find(text)
        extractedData["idNumber"] = idMatch?.value
        
        // Extract Name (usually appears after "Name" or before ID number)
        for (i in lines.indices) {
            val line = lines[i].trim()
            if (line.matches(Regex(".*[A-Za-z]{3,}.*")) && 
                !line.contains(Regex("\\d{3}-\\d{4}")) &&
                line.length > 3) {
                extractedData["fullName"] = line
                break
            }
        }
        
        // Extract Nationality
        val nationalityKeywords = listOf("NATIONALITY", "الجنسية", "UNITED ARAB EMIRATES", "UAE")
        for (line in lines) {
            for (keyword in nationalityKeywords) {
                if (line.uppercase().contains(keyword)) {
                    extractedData["nationality"] = line.trim()
                    break
                }
            }
        }
    }
    
    private fun extractBackSideData(text: String) {
        val lines = text.split("\n")
        
        // Extract Card Number from back (often clearer than front)
        val cardNumberPattern = Regex("(?:Card Number|رقم البطاقة)[^\\d]*(\\d+)")
        val cardMatch = cardNumberPattern.find(text)
        if (cardMatch != null && cardMatch.groups.size > 1) {
            val cardNumber = cardMatch.groups[1]?.value
            if (!cardNumber.isNullOrBlank()) {
                extractedData["cardNumber"] = cardNumber.trim()
            }
        }
        
        // Extract Occupation
        val occupationPattern = Regex("(?:Occupation|المهنة)[^:]*:[^\\n]*([^\\n]+)")
        val occupationMatch = occupationPattern.find(text)
        if (occupationMatch != null && occupationMatch.groups.size > 1) {
            val occupation = occupationMatch.groups[1]?.value
            if (!occupation.isNullOrBlank()) {
                extractedData["occupation"] = occupation.trim()
            }
        }
        
        // Extract Employer
        val employerPattern = Regex("(?:Employer|صاحب العمل)[^:]*:[^\\n]*([^\\n]+)")
        val employerMatch = employerPattern.find(text)
        if (employerMatch != null && employerMatch.groups.size > 1) {
            val employer = employerMatch.groups[1]?.value
            if (!employer.isNullOrBlank()) {
                extractedData["employer"] = employer.trim()
            }
        }
        
        // Extract Issuing Place
        val issuingPlacePattern = Regex("(?:Issuing Place|مكان الإصدار)[^:]*:[^\\n]*([^\\n]+)")
        val issuingPlaceMatch = issuingPlacePattern.find(text)
        if (issuingPlaceMatch != null && issuingPlaceMatch.groups.size > 1) {
            val issuingPlace = issuingPlaceMatch.groups[1]?.value
            if (!issuingPlace.isNullOrBlank()) {
                extractedData["issuingPlace"] = issuingPlace.trim()
            }
        }
        
        // Extract MRZ data which may have more reliable info
        var mrzLines = lines.filter { it.count { c -> c == '<' } > 5 }
        if (mrzLines.isNotEmpty()) {
            extractedData["mrzData"] = mrzLines.joinToString("\n")
            
            // Try to extract embedded ID number from MRZ (format should contain 784YYYY7XXXXXXX)
            val mrzIdPattern = Regex("784\\d{4}7\\d{7}")
            val mrzIdMatch = mrzIdPattern.find(mrzLines.joinToString(""))
            if (mrzIdMatch != null && extractedData["idNumber"].isNullOrBlank()) {
                val idNumber = mrzIdMatch.value
                if (idNumber.length >= 15) {
                    // Format the ID with dashes for consistency
                    val formatted = "${idNumber.substring(0, 3)}-${idNumber.substring(3, 7)}-${idNumber.substring(7, 14)}-${idNumber.substring(14)}"
                    extractedData["idNumber"] = formatted
                }
            }
        }
        
        // Extract dates (pattern: DD/MM/YYYY)
        val datePattern = Regex("(\\d{2}/\\d{2}/\\d{4})")
        val dates = datePattern.findAll(text).map { it.value }.toList()
        
        if (dates.size >= 2) {
            extractedData["issueDate"] = dates[0]
            extractedData["expiryDate"] = dates[1]
        }
        
        // Extract Date of Birth (look for specific patterns)
        for (line in lines) {
            if (line.contains("BIRTH") || line.contains("الميلاد") || line.contains("DOB")) {
                val dobMatch = datePattern.find(line)
                extractedData["dateOfBirth"] = dobMatch?.value
                break
            }
        }
    }
    
    private fun finishWithResult(status: String, data: Map<String, Any?>?) {
        val intent = Intent().apply {
            putExtra("status", status)
            if (data != null) {
                for ((key, value) in data) {
                    putExtra(key, value?.toString())
                }
            }
        }
        setResult(RESULT_OK, intent)
        finish()
    }
    
    private fun finishWithError(error: String) {
        val intent = Intent().apply {
            putExtra("status", RESULT_ERROR)
            putExtra("error", error)
        }
        setResult(RESULT_OK, intent)
        finish()
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // Full cleanup of resources
        try {
            // Clear ImageAnalysis first to stop any ongoing processing
            imageAnalyzer?.clearAnalyzer()
            imageAnalyzer = null
            
            // Unbind camera
            val cameraProvider = ProcessCameraProvider.getInstance(this).get()
            cameraProvider.unbindAll()
        } catch (e: Exception) {
            Log.e(TAG, "Error releasing camera in onDestroy: ${e.message}")
        }
        
        // Shutdown executors and close resources
        cameraExecutor.shutdown()
        textRecognizer.close()
        
        // Reset all state
        camera = null
        imageCapture = null
        isCapturing = false
    }
    
    override fun onResume() {
        super.onResume()
        // Restart camera when activity resumes, but only if we haven't completed scanning
        if (scanningStep != ScanningStep.COMPLETED && ::viewFinder.isInitialized) {
            // Small delay to ensure the surface is ready
            lifecycleScope.launch {
                delay(200)
                runOnUiThread {
                    if (scanningStep != ScanningStep.COMPLETED) {
                        startCamera()
                    }
                }
            }
        }
    }

    override fun onPause() {
        super.onPause()
        // Release camera resources when activity is paused
        try {
            // Unbind camera when paused to release resources
            val cameraProvider = ProcessCameraProvider.getInstance(this).get()
            cameraProvider.unbindAll()
            
            // Clear ImageAnalysis to stop processing immediately
            imageAnalyzer?.clearAnalyzer()
            
            // Set camera references to null to avoid any potential memory leaks
            camera = null
            imageCapture = null
            imageAnalyzer = null
            isCapturing = false  // Reset capture state
        } catch (exc: Exception) {
            Log.e(TAG, "Error unbinding camera: ${exc.message}")
        }
    }
    
    private fun restartCameraForNextStep() {
        lifecycleScope.launch {
            try {
                Log.d(TAG, "Restarting camera for next scanning step: ${scanningStep.name}")
                Log.d(TAG, "Current isCapturing state before restart: $isCapturing")
                
                // First, completely stop the camera and clear ImageAnalysis
                val cameraProvider = ProcessCameraProvider.getInstance(this@EmiratesIdScannerActivity).get()
                cameraProvider.unbindAll()
                
                // Clear camera references and reset capture state
                camera = null
                imageCapture = null
                imageAnalyzer?.clearAnalyzer()  // Clear the analyzer to stop processing
                imageAnalyzer = null
                isCapturing = false  // Reset capture state for next step
                Log.d(TAG, "Camera resources cleared and isCapturing reset to false")
                
                // Wait a bit to ensure resources are fully released
                delay(750)
                
                // Update UI first
                runOnUiThread {
                    updateInstruction()
                }
                
                // Small additional delay for UI update
                delay(250)
                
                // Restart camera
                runOnUiThread {
                    if (scanningStep != ScanningStep.COMPLETED) {
                        startCamera()
                        Log.d(TAG, "Camera restarted successfully for ${scanningStep.name} side")
                    }
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Failed to restart camera: ${e.message}")
                
                // Fallback: try a simpler restart after a longer delay
                try {
                    delay(1500)
                    runOnUiThread {
                        if (scanningStep != ScanningStep.COMPLETED) {
                            isCapturing = false  // Ensure state is reset
                            startCamera()
                            Log.d(TAG, "Camera restarted with fallback method")
                        }
                    }
                } catch (e2: Exception) {
                    Log.e(TAG, "Fallback camera restart also failed: ${e2.message}")
                    // If we still can't restart, show an error to user
                    runOnUiThread {
                        instructionText.text = "خطأ في إعادة تشغيل الكاميرا. يرجى إعادة المحاولة"
                        isCapturing = false  // Reset state even on error
                    }
                }
            }
        }
    }
}
